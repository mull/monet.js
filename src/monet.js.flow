/**
 * Flowtype definitions for monet
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface Setoid<A>{
    equals(other: A): boolean,
    fantasy - land / equals(other: A): boolean
}
declare interface Functor<T>{
    map<V>(fn: (val: T) => V): Functor<V>,
    fantasy - land / map<V>(fn: (val: T) => V): Functor<V >
}
declare interface Applicative<T>{
    ap<V>(afn: Applicative<(val: T) => V>): Applicative<V>,
    fantasy - land / ap<V>(afn: Applicative<(val: T) => V>): Applicative<V >
}
declare interface Chain<T>{
    chain<V>(fn: (val: T) => Chain<V>): Chain<V>,
    fantasy - land / chain<V>(fn: (val: T) => Chain<V>): Chain<V >
}
declare type Bind<T>= {
    bind<V>(fn: (val: T) => Bind<V>): Bind<V>,
    chain<V>(fn: (val: T) => Bind<V>): Bind<V>,
    flatMap<V>(fn: (val: T) => Bind<V>): Bind<V>,
    join<V>(): Bind<V >
} & Chain
declare interface Catamorphism<F, T>{
    cata<C>(l: (e?: F) => C, r: (v: T) => C): C
}
declare export interface ITraversable<T>{
    foldLeft<V>(initial: V): (fn: (acc: V, val: T) => V) => V,
    foldRight<V>(initial: V): (fn: (val: T, acc: V) => V) => V
}
/**
 * **************************************************************
 * Basic Monad Interface
 */
declare type IMonad<T>= {
    bind<V>(fn: (val: T) => IMonad<V>): IMonad<V>,
    flatMap<V>(fn: (val: T) => IMonad<V>): IMonad<V>,
    chain<V>(fn: (val: T) => IMonad<V>): IMonad<V>,
    map<V>(fn: (val: T) => V): IMonad<V>,
    join<V>(): IMonad<V>,
    takeLeft(m: IMonad<T>): IMonad<T>,
    takeRight(m: IMonad<T>): IMonad<T>,
    undefined: string
} & Functor & Bind & Applicative
declare type IMonadFactory = {
    (val: T): IMonad<T >
} & Function
declare interface IMonadStatic {
    unit: IMonadFactory, of: IMonadFactory,
        pure: IMonadFactory
}
/**
 * **************************************************************
 * Identity
 */
declare export type Identity<T>= {
    bind<V>(fn: (val: T) => Identity<V>): Identity<V>,
    flatMap<V>(fn: (val: T) => Identity<V>): Identity<V>,
    chain<V>(fn: (val: T) => Identity<V>): Identity<V>,
    map<V>(fn: (val: T) => V): Identity<V>,
    join<V>(): Identity<V>,
    takeLeft(m: Identity<T>): Identity<T>,
    takeRight(m: Identity<T>): Identity<T>,
    ap<V>(applyFn: Identity<(val: T) => V>): Identity<V>,
    contains(val: T): boolean,
    every(fn: (e: T) => boolean): boolean,
    forall(fn: (e: T) => boolean): boolean,
    exists(fn: (e: T) => boolean): boolean,
    forEach(fn: (val: T) => void): void,
    get(): T,
    toArray(): Array<T>,
    toSet(): Set<T>,
    toList(): List<T>,
    to<I>(ctor: (iter: Iterable<T>) => I): I
} & IMonad & Setoid & Iterable
declare type IIdentityFactory = {
    (value: V): Identity<V >
} & IMonadFactory
declare type IIdentityStatic = {
    unit: IIdentityFactory,
    of: IIdentityFactory,
    pure: IIdentityFactory,
    isOfType(target: any): boolean,
    isInstance(target: any): Identity
} & IIdentityFactory & IMonadStatic
declare export var Identity: IIdentityStatic;
/**
 * **************************************************************
 * Maybe
 */
declare export type Maybe<T>= {
    bind<V>(fn: (val: T) => Maybe<V>): Maybe<V>,
    flatMap<V>(fn: (val: T) => Maybe<V>): Maybe<V>,
    chain<V>(fn: (val: T) => Maybe<V>): Maybe<V>,
    map<V>(fn: (val: T) => V): Maybe<V>,
    join<V>(): "NO PRINT IMPLEMENTED: ConditionalType",
    takeLeft(m: Maybe<T>): Maybe<T>,
    takeRight(m: Maybe<T>): Maybe<T>,
    ap<V>(maybeFn: Maybe<(val: T) => V>): Maybe<V>,
    cata<Z>(none: () => Z, some: (val: T) => Z): Z,
    fold<V>(val: V): (fn: (val: T) => V) => V,
    catchMap(fn: () => Maybe<T>): Maybe<T>,
    filter(fn: (val: T) => boolean): Maybe<T>,
    filterNot(fn: (val: T) => boolean): Maybe<T>,
    isSome(): boolean,
    isJust(): boolean,
    isNone(): boolean,
    isNothing(): boolean,
    some(): T,
    just(): T,
    orSome(val: T): T,
    orJust(val: T): T,
    getOrElse(val: T): T,
    orLazy(fn: () => T | null | void): T,
    orNull(): T | null,
    orUndefined(): T | void,
    orElse(maybe: Maybe<T>): Maybe<T>,
    orNoneIf(val: boolean): Maybe<T>,
    orNothingIf(val: boolean): Maybe<T>,
    contains(val: T): boolean,
    every(fn: (e: T) => boolean): boolean,
    forall(fn: (e: T) => boolean): boolean,
    exists(fn: (e: T) => boolean): boolean,
    forEach(fn: (val: T) => void): void,
    orElseRun(fn: () => void): void,
    toArray(): Array<T>,
    toSet(): Set<T>,
    toList(): List<T>,
    toEither<E>(left?: E): Either<E,
    T>,
    toValidation<E>(fail?: E): Validation<E,
    T>,
    to<I>(ctor: (iter: Iterable<T>) => I): I
} & Setoid & ITraversable & Catamorphism & Iterable
declare type ISomeStatic = {
    (value: V): Maybe<V >
} & IMonadFactory
declare type INoneStatic = {
    (): Maybe<V >
} & IMonadFactory
declare type IMaybeStatic = {
    Some: ISomeStatic,
    some: ISomeStatic,
    Just: ISomeStatic,
    None: INoneStatic,
    none: INoneStatic,
    Nothing: INoneStatic,
    fromFalsy<V>(val: V | null | void): Maybe<V>,
    fromNull<V>(val: V | null | void): Maybe<V>,
    fromUndefined<V>(val: V | void): Maybe<V>,
    unit: ISomeStatic,
    of: ISomeStatic,
    pure: ISomeStatic,
    isOfType(target: any): boolean,
    isInstance(target: any): Maybe
} & IMonadStatic
declare export var Some: ISomeStatic;
declare export var Just: ISomeStatic;
declare export var None: INoneStatic;
declare export var Nothing: INoneStatic;
declare export var Maybe: IMaybeStatic;
/**
 * **************************************************************
 * Either
 */
declare export type Either<E, T>= {
    bind<V>(fn: (val: T) => Either<E, V>): Either<E,
    V>,
    flatMap<V>(fn: (val: T) => Either<E, V>): Either<E,
    V>,
    chain<V>(fn: (val: T) => Either<E, V>): Either<E,
    V>,
    map<V>(fn: (val: T) => V): Either<E,
    V>,
    join<V>(): Either<E,
    V>,
    takeLeft(m: Either<E, T>): Either<E,
    T>,
    takeRight(m: Either<E, T>): Either<E,
    T>,
    ap<V>(eitherFn: Either<E, (val: T) => V>): Either<E,
    V>,
    cata<Z>(leftFn: (err: E) => Z, rightFn: (val: T) => Z): Z,
    fold<Z>(leftFn: (err: E) => Z, rightFn: (val: T) => Z): Z,
    catchMap<F>(fn: (err: E) => Either<F, T>): Either<F,
    T>,
    swap(): Either<T,
    E>,
    bimap<Z,
    V>(leftFn: (err: E) => Z, rightFn: (val: T) => V): Either<Z,
    V>,
    leftMap<F>(fn: (leftVal: E) => F): Either<F,
    T>,
    isRight(): boolean,
    isLeft(): boolean,
    right(): T,
    left(): E,
    forEach(fn: (val: T) => void): void,
    forEachLeft(fn: (val: E) => void): void,
    toValidation(): Validation<E,
    T>,
    toMaybe(): Maybe<T >
} & IMonad & Setoid & ITraversable & Catamorphism
declare type IEitherStatic = {
    Right: IRightStatic,
    right: IRightStatic,
    Left: ILeftStatic,
    left: ILeftStatic,
    unit: IRightStatic,
    of: IRightStatic,
    pure: IRightStatic,
    isOfType(target: any): boolean,
    isInstance(target: any): Either
} & IMonadStatic
declare type IRightStatic = {
    (val: V): Either<F,
    V >
} & IMonadFactory
declare type ILeftStatic = {
    (val: F): Either<F,
    V >
} & IMonadFactory
declare export var Either: IEitherStatic;
declare export var Right: IRightStatic;
declare export var Left: ILeftStatic;
/**
 * **************************************************************
 * Validation
 */
declare type IValidationAcc = {
    (): IValidationAcc
} & Function
declare export type Validation<E, T>= {
    bind<V>(fn: (val: T) => Validation<E, V>): Validation<E,
    V>,
    flatMap<V>(fn: (val: T) => Validation<E, V>): Validation<E,
    V>,
    chain<V>(fn: (val: T) => Validation<E, V>): Validation<E,
    V>,
    map<V>(fn: (val: T) => V): Validation<E,
    V>,
    join<V>(): Validation<E,
    V>,
    takeLeft(m: Validation<E, T>): Validation<E,
    T>,
    takeRight(m: Validation<E, T>): Validation<E,
    T>,
    ap<V>(eitherFn: Validation<E, (val: T) => V>): Validation<E,
    V>,
    cata<Z>(failFn: (fail: E) => Z, successFn: (val: T) => Z): Z,
    fold<Z>(failFn: (fail: E) => Z, successFn: (val: T) => Z): Z,
    catchMap<F>(fn: (fail: E) => Validation<F, T>): Validation<F,
    T>,
    swap(): Validation<T,
    E>,
    bimap<F,
    V>(fnF: (fail: E) => F, fnS: (val: T) => V): Validation<F,
    V>,
    failMap<F>(fn: (fail: E) => F): Validation<F,
    T>,
    isSuccess(): boolean,
    isFail(): boolean,
    success(): T,
    fail(): E,
    forEach(fn: (val: T) => void): void,
    forEachFail(fn: (val: E) => void): void,
    acc(): Validation<E,
    IValidationAcc>,
    toEither(): Either<E,
    T>,
    toMaybe(): Maybe<T >
} & IMonad & Setoid & ITraversable & Catamorphism
declare type IValidationStatic = {
    Success: ISuccessStatic,
    Fail: IFailStatic,
    success: ISuccessStatic,
    fail: IFailStatic,
    unit: ISuccessStatic,
    of: ISuccessStatic,
    pure: ISuccessStatic,
    point: ISuccessStatic,
    isOfType(target: any): boolean,
    isInstance(target: any): Validation
} & IMonadStatic
declare type ISuccessStatic = {
    (val: T): Validation<E,
    T >
} & IMonadFactory
declare type IFailStatic = {
    (err: E): Validation<E,
    T >
} & IMonadFactory
declare export var Validation: IValidationStatic;
declare export var Success: ISuccessStatic;
declare export var Fail: IFailStatic;
/**
 * **************************************************************
 * List
 */
declare export type List<T>= {
    bind<V>(fn: (val: T) => List<V>): List<V>,
    flatMap<V>(fn: (val: T) => List<V>): List<V>,
    chain<V>(fn: (val: T) => List<V>): List<V>,
    map<V>(fn: (val: T) => V): List<V>,
    join<V>(): List<V>,
    takeLeft<V>(m: List<V>): List<T>,
    takeRight<V>(m: List<V>): List<V>,
    ap<V>(listFn: List<(val: T) => V>): List<V>,
    filter(fn: (val: T) => boolean): List<T>,
    filterNot(fn: (val: T) => boolean): List<T>,
    find(fn: (val: T) => boolean): Maybe<NonNullable<T >> ,
    cons(a: T): List<T>,
    snoc(a: T): List<T>,
    isNEL(): boolean,
    size(): number,
    head(): T | void,
    headMaybe(): Maybe<NonNullable<T >> ,
    append(list: List<T>): List<T>,
    concat(list: List<T>): List<T>,
    reverse(): List<T>,
    tail(): List<T>,
    tails(): List<List<T >> ,
    flatten<V>(): List<V>,
    flattenMaybe<V>(): "NO PRINT IMPLEMENTED: ConditionalType",
    contains(val: T): boolean,
    every(fn: (e: T) => boolean): boolean,
    forall(fn: (e: T) => boolean): boolean,
    exists(fn: (e: T) => boolean): boolean,
    forEach(fn: (val: T) => void): void,
    sequence<V>(m: IMaybeStatic): Maybe<List<V >> ,
    sequence<E,
    V>(m: IEitherStatic): Either<E,
    List<V >> ,
    sequence<E,
    V>(m: IValidationStatic): Validation<List<E>,
    List<V >> ,
    sequence<V>(m: IIOStatic): IO<List<V >> ,
    sequence<E,
    A>(m: IReaderStatic): Reader<E,
    List<A >> ,
    sequenceMaybe<V>(): Maybe<List<V >> ,
    sequenceEither<E,
    V>(): Either<E,
    List<V >> ,
    sequenceValidation<E,
    V>(): Validation<List<E>,
    List<V >> ,
    sequenceIO<V>(): IO<List<V >> ,
    sequenceReader<E,
    A>(): Reader<E,
    List<A >> ,
    toArray(): Array<T>,
    toSet(): Set<T>,
    to<I>(ctor: (iter: Iterable<T>) => I): I
} & IMonad & Setoid & ITraversable & Iterable
declare export type Nil = {
    cons<T>(a: T): List<T>,
    append<T>(list: List<T>): List<T>,
    concat<T>(list: List<T>): List<T >
} & List
declare type IListFactory = {
    (val: T): List<T >
} & IMonadFactory
declare type IListStatic = {
    (): List<T>,
    (val: T, tail?: List<T>): List<T>,
    fromArray<T>(arr: T[]): List<T>,
    from<T>(iter: Iterable<T>): List<T>,
    unit: IListFactory,
    of: IListFactory,
    pure: IListFactory,
    isOfType(target: any): boolean,
    isInstance(target: any): List
} & IMonadStatic
declare export var List: IListStatic;
declare export var Nil: Nil;
/**
 * **************************************************************
 * NEL
 */
declare export type NEL<T>= {
    bind<V>(fn: (val: T) => NEL<V>): NEL<V>,
    flatMap<V>(fn: (val: T) => NEL<V>): NEL<V>,
    chain<V>(fn: (val: T) => NEL<V>): NEL<V>,
    map<V>(fn: (val: T) => V): NEL<V>,
    join<V>(): NEL<V>,
    takeLeft<V>(m: NEL<V>): NEL<T>,
    takeRight<V>(m: NEL<V>): NEL<V>,
    mapTails<V>(fn: (val: NEL<T>) => V): NEL<V>,
    cobind<V>(fn: (val: NEL<T>) => V): NEL<V>,
    coflatMap<V>(fn: (val: NEL<T>) => V): NEL<V>,
    cojoin(): NEL<NEL<T >> ,
    copure(): T,
    extract(): T,
    ap<V>(listFn: NEL<(val: T) => V>): NEL<V>,
    reduceLeft(fn: (acc: T, element: T) => T): T,
    filter(fn: (val: T) => boolean): List<T>,
    filterNot(fn: (val: T) => boolean): List<T>,
    find(fn: (val: T) => boolean): Maybe<T>,
    cons(a: T): NEL<T>,
    snoc(a: T): NEL<T>,
    isNEL(): boolean,
    size(): number,
    head(): T,
    append(list: NEL<T>): NEL<T>,
    concat(list: NEL<T>): NEL<T>,
    reverse(): NEL<T>,
    tail(): List<T>,
    tails(): NEL<NEL<T >> ,
    contains(val: T): boolean,
    every(fn: (e: T) => boolean): boolean,
    forall(fn: (e: T) => boolean): boolean,
    exists(fn: (e: T) => boolean): boolean,
    forEach(fn: (val: T) => void): void,
    flatten<V>(): "NO PRINT IMPLEMENTED: ConditionalType",
    flattenMaybe<V>(): "NO PRINT IMPLEMENTED: ConditionalType",
    toArray(): Array<T>,
    toList(): List<T>,
    toSet(): Set<T>,
    to<I>(ctor: (iter: Iterable<T>) => I): I
} & IMonad & Setoid & ITraversable & Iterable
declare export type NonEmptyList<T>= NEL<T>;
declare type INELFactory = {
    (val: T, tail?: List<T>): NEL<T >
} & IMonadFactory
declare type INELStatic = {
    fromList<T>(arr: List<T>): Maybe<NEL<T >> ,
    fromArray<T>(arr: T[]): Maybe<NEL<T >> ,
    from<T>(iter: Iterable<T>): Maybe<NEL<T >> ,
    unit: INELFactory,
    of: INELFactory,
    pure: INELFactory,
    isOfType(target: any): boolean,
    isInstance(target: any): NEL
} & INELFactory & IMonadStatic
declare export var NonEmptyList: INELStatic;
declare export var NEL: INELStatic;
/**
 * **************************************************************
 * IO
 */
declare export type IO<T>= {
    bind<V>(fn: (val: T) => IO<V>): IO<V>,
    flatMap<V>(fn: (val: T) => IO<V>): IO<V>,
    chain<V>(fn: (val: T) => IO<V>): IO<V>,
    map<V>(fn: (v: T) => V): IO<V>,
    join<V>(): IO<V>,
    takeLeft<X>(m: IO<X>): IO<T>,
    takeRight<V>(m: IO<V>): IO<V>,
    ap<V>(ioFn: IO<(v: T) => V>): IO<V>,
    run(): T,
    perform(): T,
    performUnsafeIO(): T
} & IMonad
declare type IIOFactory = {
    (fn: () => T): IO<T >
} & IMonadFactory
declare type IIOStatic = {
    unit: IIOFactory,
    of: IIOFactory,
    pure: IIOFactory,
    io: IIOFactory,
    isOfType(target: any): boolean,
    isInstance(target: any): IO
} & IIOFactory & IMonadStatic
declare export var IO: IIOStatic;
/**
 * **************************************************************
 * Reader
 */
declare export type Reader<E, A>= {
    bind<B>(fn: (val: A) => Reader<E, B>): Reader<E,
    B>,
    flatMap<B>(fn: (val: A) => Reader<E, B>): Reader<E,
    B>,
    chain<B>(fn: (val: A) => Reader<E, B>): Reader<E,
    B>,
    map<B>(fn: (val: A) => B): Reader<E,
    B>,
    join<B>(): Reader<E,
    B>,
    takeLeft<X>(m: Reader<E, X>): Reader<E,
    A>,
    takeRight<B>(m: Reader<E, B>): Reader<E,
    B>,
    ap<B>(rfn: Reader<E, (val: A) => B>): Reader<E,
    B>,
    run(config: E): A,
    local<X>(fn: (val: X) => E): Reader<X,
    A >
} & IMonad
declare type IReaderFactory = {
    (fn: (env: E) => A): Reader<E,
    A >
} & IMonadFactory
declare type IReaderStatic = {
    unit: IReaderFactory,
    of: IReaderFactory,
    pure: IReaderFactory,
    point: IReaderFactory,
    ask<E>(): Reader<E,
    E>,
    isOfType(target: any): boolean,
    isInstance(target: any): Reader
} & IReaderFactory & IMonadStatic
declare export var Reader: IReaderStatic;
/**
 * **************************************************************
 * Free
 */
declare export type Free<A>= {
    bind<V>(fn: (val: A) => Free<V>): Free<V>,
    flatMap<V>(fn: (val: A) => Free<V>): Free<V>,
    chain<V>(fn: (val: A) => Free<V>): Free<V>,
    join<V>(): Free<V>,
    map<V>(fn: (val: A) => V): Free<V>,
    takeLeft<X>(other: Free<X>): Free<A>,
    takeRight<B>(other: Free<B>): Free<B>,
    resume<FFA>(): Either<FFA,
    A>,
    go<FFA>(extract: (sus: FFA) => Free<A>): A
} & IMonad
declare type IFreeStatic = {
    Return: IReturnStatic,
    Suspend: ISuspendStatic,
    unit: IReturnStatic,
    of: IReturnStatic,
    pure: IReturnStatic,
    liftF<A,
    FA>(fa: FA): Free<A>,
    isOfType(target: any): boolean,
    isInstance(target: any): Free
} & IMonadStatic
declare type IReturnStatic = {
    (a: A): Free<A >
} & IMonadFactory
declare type ISuspendStatic = {
    (ffa: FFA): Free<A >
} & IMonadFactory
declare export var Free: IFreeStatic;
declare export var Return: IReturnStatic;
declare export var Suspend: ISuspendStatic;